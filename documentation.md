# Документация

## Схема файлов проекта
``` bash
.config/ # Содержит конфигурационные файлы запуска
  |--- config.xml # Файл с параметрами свечей
  |--- config_env.sh # Содержит константы для запуска bash скриптов
  |--- requirements.txt # Содержит версии необходимых python библиотек

.vscode/ # Содержит файлы для удобства использования vscode

utils/ # Впомогательные файлы запуска/настройки проекта
  |-- activate_venv.sh # Файл активирующий venv окружение (выполнять через source)
  |-- build_env.sh # Создает необходимые файлы проекта, создает venv окружение, устанавливает нужные библиотеки
  |-- run_default.sh # Запускает программу дефолтным образом (настраивается в config_env.sh)
  |-- run_tests.sh # Запускает несколько тестов с проверкой результата, перед запуском необходимо правильно указать внутренние константы 

.gitignore # Файлы игнорируемые при коммитах
Makefile # Инструкции для простого запуска и билдинга проекта
README.md # Описание проекта, его конфигурации и запуска
documentation.md # Подробное описание проекта
main.py # Основной код программы, выполняющий вычисления
.env # Содержит указание интерпретатора python для vscode (создается при билдинге проекта)

.cache/ # Содержит кэш файлы проекта (создается при билдинге проекта)
  |-- requirements.txt.intelled содержит файл с указанием уже установленных библиотек (для оптимизации работы build_env.sh)

logs/ # Содержит лог-файлы (создается при запуске программы)

```

## Общая схема работы программы 
1. Настройка логирования
2. Парсинг аргументов командной строки
3. Чтение и парсинг конфигурационных файлов, получение из них конфигурационных параметров
4. Формирование спарк-сессии
5. Чтение базы данных
6. Расчет свечей
7. Сохранение их файлы
8. Остановка спарк-сессии

## Краткое описание классов
### `CandleConfig`
Отвечает за хранение параметров свеч, получает их через словарь и/или через отдельные аргументы.  

Методы:
``` python
__init__(
    self,
    params: dict = {},
    width_ms="300000",
    date_from="19000101",  # yyyyMMdd
    date_to="20200101",  # yyyyMMdd
    time_from="1000",  # HHmm
    time_to="1800"  # HHmm
)
```

### `Config`
Отвечает за хранение и извлечение параметров запуска программы из файлов, содержит в себе класс CandleConfig.  

Методы:
``` python
__init__(
    self,
    args: dict,
) 
_parse_xml_file(self, file) -> dict # Парсит XML файл, возвращает словарь состоящий из всех извлеченных параметров (нужен для получения параметров свечей)
```

## Краткое описание работы всех функций 
Здесь я буду при помощи "--" обозначать, что функция вызывается внутри другой. Порядок описания функций соответствует порядку их вызова в программе.
``` python
setup_logger(log_dir: Path = Path(DEF_LOG_DIR)) # Настраивает логгер и хэндлеры для вывода в консоль и в файл
parse_args() # Парсит аргументы командной строки
Config(args) # Формирование объекта Config
make_candles(config: Config) # Главная функция выполняет вычисление и сохранение свечей в файлы
-- config_spark_session() -> SparkSession # Настраивает и создает спарк-сессию
-- get_trades_dataframe(spark: SparkSession, config: Config) -> DataFrame # Чтение базы данных и формирование датафрейма сделок
-- calculate_candles(trades: DataFrame, candle_config: CandleConfig) -> DataFrame # Выполняет все вычисления свечей, возвращает датафрейм свечей (ленивые)
-- format_candle(candles: DataFrame) -> DataFrame # Выполняет форматирование свечей (округление полей, форматирование времени, триминг)
-- save_candles(candles: DataFrame, config: Config) # Сохраняет свечи в файлы 
   -- try_remove_dir(dir: str) # Удаляет директорию и все поддиректории или вызывает ошибку
```

## Подробное описание функций отвечающих за расчет свечей 
### `calculate_candles`
Выполняет ленивые вычисления свечей, возвращает датафрейм свечей:
1. Отфильтровывает записи сделок, которые не будут участвовать в формировании свечей (те что не соответствуют параметрам времени формирования свечей)
2. Добавляет в таблицу сделок новый столбец "CANDLE_MOMENT", это вычисляемое поле сопоставляет каждой сделке время начала той свечи, которой она соответствует. Оно уникальным образом идентифицирует каждую свечу
3. Выполняется repartition(MIN_PARTION_COUNT, "#SYMBOL", "CANDLE_MOMENT") датафрейма сделок. Таким образом все сделки соответствующие одной свече окажутся в одной партиции. Репартиционирование по "#SYMBOL" не является обязательным, однако мне показалось это уместным, для разбиения на более маленькие группы, а как следствие более равномерное разбиение всех сделок между партициями. Может как замедлить, так и ускорить выполнение программы
4. Выполняется формирование статистик для каждой сделки: цены первой (колонка "OPEN") и последней (колонка "CLOSE") сделок по свече, к которой относится данная сделка, при помощи оконной функции
``` python
window_spec = Window \
    .partitionBy("#SYMBOL", "CANDLE_MOMENT") \
    .orderBy("MOMENT", "ID_DEAL")

trade_stats = trades.select(
    "#SYMBOL", \
    "CANDLE_MOMENT", \
    "PRICE_DEAL", \
    F.first("PRICE_DEAL").over(window_spec).alias("OPEN"), \
    F.last("PRICE_DEAL").over(window_spec).alias("CLOSE")
)
```

5. К полученной таблице статистик приминяются агрегационные функции поиска максимума и минимума свечей, результат этого действия - таблица свечей
``` python
candles = trade_stats \
    .groupBy(
        F.col("#SYMBOL").alias("SYMBOL"),
        F.col("CANDLE_MOMENT").alias("MOMENT")) \
    .agg(
        F.first("OPEN").alias("OPEN"),
        F.max("PRICE_DEAL").alias("HIGH"),
        F.min("PRICE_DEAL").alias("LOW"),
        F.last("CLOSE").alias("CLOSE")
)
```

### `save_candles`
Сохраняет свечи в файлы.  
План:
1. Поиск всех уникальных SYMBOLS свечей - первое вычисление
2. Сохранение свечей в кэш
3. Пересоздание директории вывода (опциональное)
4. После чего в цикле из всех партиций собираются свечи соответствующие каждому символу (опционально сортируются) и сохраняются в файл выходной директории
